cmake_minimum_required (VERSION 3.18)
project (plt)

include_directories(${CMAKE_BINARY_DIR})

# CMP0074 policy enable find_* to use <PackageName>_ROOT variables to find
# packages.
if(POLICY CMP0074)
  cmake_policy(SET CMP0074 NEW)
endif()

# Include helper functions
set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
include(GenerateDiaHeader)

# Export executables to "bin" directory
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/bin)

# Enable C++11
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Enable Debug and Release builds
if(NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE Debug CACHE STRING
    "Build type, Debug or Release" FORCE)
endif()
message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
IF(CMAKE_COMPILER_IS_GNUCC)
  SET(CMAKE_C_FLAGS   "${CMAKE_C_FLAGS}   -Wall -std=c11   -pthread -g")
  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -std=c++11 -pthread -g")
ENDIF(CMAKE_COMPILER_IS_GNUCC)



# Add code coverage support for Gcov using GCC
set(BUILD_CODE_COVERAGE ON CACHE BOOL
  "Set BUILD_CODE_COVERAGE to OFF to disable code coverage")
if(BUILD_CODE_COVERAGE AND NOT UNIX)
  message(WARNING "Code coverage is only available for UNIX systems")
  set(BUILD_CODE_COVERAGE OFF)
elseif(BUILD_CODE_COVERAGE AND NOT CMAKE_COMPILER_IS_GNUCC AND NOT CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  message(WARNING "Code coverage is only available for GNU compiler and Clang compiler")
  set(BUILD_CODE_COVERAGE OFF)
endif()

message(STATUS "Code coverage: ${BUILD_CODE_COVERAGE}")
if(BUILD_CODE_COVERAGE)
  include(CodeCoverage)
  APPEND_COVERAGE_COMPILER_FLAGS()
  # Exclude all code not directly generated by user from code coverage
  set(COVERAGE_LCOV_EXCLUDES
    '/usr/*'
    '${PROJECT_SOURCE_DIR}/test/*'
    '${PROJECT_SOURCE_DIR}/extern/*')
    
  set(COVERAGE_GCOVR_EXCLUDES
    /usr/
    "${PROJECT_SOURCE_DIR}/test/"
    "${PROJECT_SOURCE_DIR}/extern/")
  # Create script to run tests for code coverage
  set(test_runner "${CMAKE_CURRENT_BINARY_DIR}/run_test.sh")
  file(CONFIGURE
          OUTPUT ${test_runner}
          CONTENT
          "cd \"${CMAKE_CURRENT_BINARY_DIR}/test\" && ctest --timeout 300 ||/bin/true\n"
          )
  # Create target for code coverage
  SETUP_TARGET_FOR_COVERAGE_LCOV(
    NAME code-coverage
    EXECUTABLE sh ${test_runner}
    DEPENDS ${test_runner}
    )
  SETUP_TARGET_FOR_COVERAGE_GCOVR_XML(
    NAME code-coverage-gcov
    EXECUTABLE sh ${test_runner}
    DEPENDS ${test_runner}
    )
endif()

# Build dia2code
add_subdirectory(extern/dia2code)

# Add option to enable special build for ENSEA's machines
set(MACHINE_ENSEA OFF CACHE BOOL
  "Set MACHINE_ENSEA to ON to build on the CentOS machine at ENSEA")

# Find library jsoncpp
set(jsoncpp_include_dir "${PROJECT_SOURCE_DIR}/extern/jsoncpp-1.8.0")
file(GLOB_RECURSE jsoncpp_sources extern/jsoncpp-1.8.0/*.cpp)

# Find library SFML
if(WIN32)
  set(SFML_ROOT "D:/Utils/SFML-2.3" CACHE STRING
    "Root directory for SFML library")
  set(CMAKE_MODULE_PATH "${SFML_ROOT}/cmake/Modules" ${CMAKE_MODULE_PATH})
else(WIN32)
  set(CMAKE_MODULE_PATH "/usr/share/SFML/cmake/Modules/" ${CMAKE_MODULE_PATH})
endif(WIN32)
if(${MACHINE_ENSEA})
  set(SFML_ROOT "/usr/lsa")
  set(CMAKE_MODULE_PATH "${SFML_ROOT}/share/SFML/cmake/Modules/" ${CMAKE_MODULE_PATH})
endif()
find_package(SFML 2 COMPONENTS graphics network window system)
if(NOT ${MACHINE_ENSEA})
  set(SFML_LIBRARIES sfml-graphics sfml-network sfml-window sfml-system)
endif()

# Find library libmicrohttpd
find_library(
  MHD_LIBRARY
  NAMES microhttpd microhttpd-10 libmicrohttpd libmicrohttpd-dll
  DOC "microhttpd library"
)

#Â Add source subdirectories
add_subdirectory(src/shared)
add_subdirectory(src/client)
add_subdirectory(src/server)

# Rapport generation
add_subdirectory(rapport)
configure_file(config.h.in ${CMAKE_BINARY_DIR}/config.h)


# Unit tests
# Set BUILD_TESTING to OFF in CMakeCache to disable tests
set(BUILD_TESTING ON CACHE BOOL
  "Set BUILD_TESTING to OFF to disable tests")
if(BUILD_TESTING)
  # Include tests scripts
  add_subdirectory(test)
endif()


add_library(restbed INTERFACE)
set_target_properties(restbed PROPERTIES
        "INTERFACE_INCLUDE_DIRECTORIES" "${CMAKE_SOURCE_DIR}/e/restbed/${CMAKE_BUILD_TYPE}/include"
        "INTERFACE_LINK_LIBRARIES" "${CMAKE_SOURCE_DIR}/${3rd_part}/restbed/${CMAKE_BUILD_TYPE}/library"
)

find_package(restbed
        PATHS
        "${CMAKE_SOURCE_DIR}/extern/restbed/${CMAKE_BUILD_TYPE}/usr/share"
)
if(NOT restbed_FOUND)
  ExternalProject_Add(restbed_external
          GIT_REPOSITORY https://github.com/corvusoft/restbed.git
          #GIT_SUBMODULES_RECURSE ON
          #GIT_CONFIG advice.detachedHead=false
          CMAKE_ARGS -DBUILD_SSL=NO  -DBUILD_SHARED=YES -DCMAKE_INSTALL_PREFIX=${CMAKE_SOURCE_DIR}/extern/restbed/${CMAKE_BUILD_TYPE} -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
          INSTALL_DIR ${CMAKE_SOURCE_DIR}/extern/restbed/${CMAKE_BUILD_TYPE}
          DEPENDS restbed
  )
  add_custom_target(restbed_install ALL DEPENDS  restbed  restbed_external)
  add_custom_command(TARGET   restbed_install
          COMMAND mkdir -p ${CMAKE_SOURCE_DIR}/${3rd_part}/restbed/${CMAKE_BUILD_TYPE}/usr/share
          COMMAND cp ${CMAKE_SOURCE_DIR}/cmake/restbed-config.cmake ${CMAKE_SOURCE_DIR}/extern/restbed/${CMAKE_BUILD_TYPE}/usr/share
  )

else()
  add_custom_target(restbed_install ALL    )
  add_custom_command(TARGET   restbed_install
          COMMAND cp ${CMAKE_SOURCE_DIR}/cmake/restbed-config.cmake ${CMAKE_SOURCE_DIR}/${3rd_part}/restbed/${CMAKE_BUILD_TYPE}/usr/share

  )
endif()
# vim: set sw=2 sts=2 et:

